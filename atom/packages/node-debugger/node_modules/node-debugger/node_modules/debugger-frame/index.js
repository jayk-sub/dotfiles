var EventEmitter = require('events').EventEmitter
  , inherits = require('util').inherits
  , q = require('q')
  , Frame = require('./lib/frame');


module.exports = FrameManager;

inherits(FrameManager, EventEmitter);
function FrameManager(connection) {
  EventEmitter.call(this);
  this.connection = connection;
  this.frames = [];

  this.connection.on('break', this.refresh.bind(this));
  this.connection.on('change', this.refresh.bind(this));
}

var manager = FrameManager.prototype;

function curriedPopulate(prop) {
  return function(frame) {
    return populateArrayProp.call(this, prop, frame);
  };
}

function populateArrayProp(prop, frame) {
  var arr = frame[prop];

  var refs = arr.map(function(local) {
    return local.value.ref;
  });

  return this
    .connection
    .lookup(refs)
    .then(function(body) {
      arr.forEach(function(local) {
        local.value = body[local.value.ref];
      });

      return frame;
    });
}

function popProp(name) {
  return function(frame) {
    var prop = frame[name];

    if (!prop) {
      return frame;
    }

    if (!prop && prop.ref !== 0) {
      return frame;
    }

    return this
      .connection
      .lookup([prop.ref])
      .then(function(body) {
        frame[name] = body[prop.ref];
        return frame;
      });
  }
}

manager.backtrace = function() {
  var self = this;

  function backtrace() {
    return q.Promise(function(res, rej) {
      self.connection.request('backtrace', null, function(err, body) {
        if (err) { return rej(err); }
        res(body.frames);
      });
    });
  }

  return backtrace();
}

/**
 * refresh data
 * @return {Promise} refresh all the frame result
 */
manager.refresh = function() {
  var self = this;

  if (!this.connection._connected) {
    self.frame = null;
    self.emit('change', self.frame);
    return;
  }

  function fetch(receiver) {
    return q.Promise(function(resolve, reject) {
      self.connection.request('frame', null, function(err, frame) {
        if (err) {
          return reject(new Error(err));
        }
        return resolve(frame);
      });
    });
  }

  function fullfill(frame) {
    return [
      popProp('func').bind(self),
      popProp('script').bind(self),
      popProp('receiver').bind(self),
      function toFrame(f) {
        try {
          return q(new Frame(f, self.connection));
        } catch(e) {
          console.error(e);
        }
      }
    ].reduce(q.when, q(frame));
  }

  return self.backtrace().then(function(frames) {
    self.frames = frames;
    self.frame = frames[0];
    return frames.reduce(function(promise, frame, i) {
      return promise.then(function() {
        return fullfill(frame);
      }).then(function(frame) {
        self.frames[i] = frame;
      })
    }, q()).then(function() {
      self.frame = self.frames[0];
      self.emit('change');
    });
  });
};

manager.get = function() {
  return this.frames;
};

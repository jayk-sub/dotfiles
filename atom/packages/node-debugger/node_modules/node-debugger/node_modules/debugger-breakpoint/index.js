var q = require('q')
  , _ = require('lodash')
  , inherits = require('util').inherits
  , EventEmitter = require('events').EventEmitter
  , Breakpoint = require('./lib/breakpoint');

inherits(BreakpointManager, EventEmitter);
function BreakpointManager(client) {
  EventEmitter.call(this);
  var self = this;

  self.client = client;
  self._breakpoints = [];

  self.client.on('change', onchange);
  self.client.on('break', onbreak);

  function onchange() {
    if (self._breakpoints) {
      self._breakpoints.forEach(function(brk) {
        delete brk._client;
      });
    }

    self._breakpoints = [];
    onbreak();
  }

  function onbreak() {
    fetch(self)
      .then(toBreakpoint.bind(self))
      .then(mergeResult)
      .then(function() { self.emit('change'); })
      .done();
  }

  function mergeResult(breakpoints) {
    breakpoints.forEach(merge);
    return self._breakpoints;
  }

  function merge(breakpoint) {
    var breakpoints = self._breakpoints
      , same = breakpoints.filter(function(item) {
          return item.number === breakpoint.number;
        });

    if (same.length) {
      same[0].merge(breakpoint);
    }
    else {
      breakpoints.push(breakpoint);
    }
  }

}

var manager = BreakpointManager.prototype;

/**
 * fetch all the breakpoints
 * @return {Promise}
 */
function fetch(manager) {
  return q.Promise(function(resolve, reject) {
    manager.client.request('listbreakpoints', null, function(err, body) {
      if (err) {
        return reject(new Error(err));
      }
      return resolve(body.breakpoints);
    });
  });
}

/**
 * get all the breakpoints
 */
manager.getBreakpoints = function() {
  return this._breakpoints;
};

manager.fetch = function() {
  return fetch(this).then(toBreakpoint.bind(this));
};

/**
 * @method create a new Breakpoint
 *
 * If success, this method will emit the `change` event.
 *
 * @param  {Object} breakpoint description - follows https://code.google.com/p/v8/wiki/DebuggerProtocol#Request_setbreakpoint
 * @return {Promise} promise Object with breakpoint callback
 *
 */
manager.create = function(breakpoint) {
  var self = this;
  return q.Promise(function(resolve, reject) {

    breakpoint = _.defaults(breakpoint, {
      enabled: true,
      ignoreCount: 0
    });

    self.client.request('setbreakpoint', breakpoint, function(err, body) {
      if (err) {
        return reject(new Error(err));
      }

      var brk = new Breakpoint({
        number: body.breakpoint,
        type: body.type,
        line: breakpoint.line,
        column: breakpoint.column,
        enabled: breakpoint.enabled,
        condition: breakpoint.condition,
        ignoreCount: breakpoint.ignoreCount
      });

      if (body.type === 'scriptName') {
        brk.scriptName = breakpoint.target;
      }

      self._breakpoints.push(brk);
      self.emit('change');

      resolve(brk);
    });
  });
};


/**
 * remove
 *
 * @param {Breakpoint} breakpoint to be removed
 */
manager.remove = function(breakpoint) {
  var self = this;

  return q.Promise(function(resolve, reject) {
    self.client.request('clearbreakpoint', {}, function(err, body) {
      if (err) {
        return reject(new Error(err));
      }

      self._breakpoints = self.getBreakpoints()
        .filter(function(brk) {
          if (breakpoint.number === brk.number) {
            delete brk._client;
            breakpoint = brk;
          }

          return breakpoint.number !== brk.number;
        });

      resolve(breakpoint);
      self.emit('change');
    });
  });
};


function toBreakpoint(breakpoints) {
  var self = this;
  return breakpoints.map(function(breakpoint) {
    var brk = new Breakpoint({
      number: breakpoint.number,
      type: breakpoint.type,
      line: breakpoint.line,
      column: breakpoint.column,
      groupId: breakpoint.groupId,
      hitCount: breakpoint.hitCount,
      enabled: breakpoint.active,
      ignoreCount: breakpoint.ignoreCount,
      _client: self.client
    });

    brk[breakpoint.type] = breakpoint.type === 'scriptId' ? breakpoint.script_id : breakpoint.script_name;
    return brk;
  });
}

module.exports = BreakpointManager;

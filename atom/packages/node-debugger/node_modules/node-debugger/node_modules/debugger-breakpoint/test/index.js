var test = require('tape')
  , sinon = require('sinon')
  , Ev = require('events').EventEmitter
  , Breakpoint = require('../lib/breakpoint')
  , Manager = require('..')
  , clinet, manager;

function setup(data) {
  debugger;
  client = new Ev()
  client.request = sinon.stub().callsArgWith(2, null,  data);
  manager = new Manager(client);
}


function setupForList() {
  setup({ breakpoints: [{
     type: 'scriptId',
     script_id: 1,
     number: 1,
     line: 100,
     column: 10,
     groupId: 1,
     hit_count: 1,
     active: true,
     ignoreCount: 0
   },
   {
     type: 'scriptId',
     script_id: 2,
     number: 2,
     line: 101,
     column: 11,
     groupId: 2,
     hit_count: 2,
     active: true,
     ignoreCount: 1
   }] });
}

test('Initialize', function(t) {
  t.plan(1);

  setupForList();

  manager._breakpoints.push(1);
  client.emit('change');
  t.equal(manager.getBreakpoints().length, 0, 'should reset everything when client have new connection');
});

test('Breakpoint Fetching', function(t) {
  t.plan(1);

  setupForList();

  client.emit('change');
  t.ok(client.request.calledWith('listbreakpoints'), 'should try to list all the breakpoints when have new connection');
});

test('Emit change when breakpoint all fetched', function(t) {
  t.plan(1);

  setupForList();

  manager.on('change', function() {
    t.equal(manager.getBreakpoints().length, 2, 'should fetch back the result');
  });
  client.emit('change');
});

test('Convert to breakpoint object', function(t) {
  t.plan(1);

  setupForList();

  manager.on('change', function() {
    t.ok(manager.getBreakpoints()[0] instanceof Breakpoint, 'should be a breakpoint instance');
  });
  client.emit('change');
});


test('Merging result', function(t) {
  t.plan(2);

  setupForList();
  var breakpoint = new Breakpoint({
    type: 'scriptId',
    script_id: 1,
    number: 1,
    line: 100,
    column: 10,
    groupId: 1,
    hit_count: 0,
    active: false,
    ignoreCount: 0
  });

  manager._breakpoints.push(breakpoint);

  manager.on('change', function() {
    t.equal(manager.getBreakpoints().length, 2, 'should still have only two items in the list');
    t.equal(manager.getBreakpoints()[0], breakpoint, 'should modify the same breakpoint');
  });

  client.emit('break');
});


test('Create breakpoint', function(t) {
  t.plan(4);

  setup({
    breakpoint: 2,
    type: 'script'
  });

  t.equal(manager.getBreakpoints().length, 0, 'should not have breakpoint before created');

  manager.on('change', function() {
    t.equal(manager.getBreakpoints().length, 1, 'should have a breakpoint');
  });

  manager.create({
    type: Breakpoint.TYPE.SCRIPT,
    target: '/path/to/js/file.js',
    line: 100,
    column: 10,
    enabled: true
  }).then(function(brk) {
    t.equal(brk.number, 2, 'should assign the correct breakpoint number');
  });

  t.ok(client.request.calledWith('setbreakpoint'), 'should try to set a breakpoint');
});


test('update breakpont', function(t) {
  t.plan(1);

  setup({
    breakpoint: 2,
    type: 'script'
  });

  var breakpoint = new Breakpoint({
    number: 1,
    type: 'scriptId',
    line: 100,
    column: 100,
    groupId: 100,
    hitCount: 100,
    enabled: true,
    ignoreCount: 19,
    _client: client
  });

  breakpoint.save();

  t.ok(client.request.calledWith('changebreakpoint'), 'should try to update the breakpoint when save called');
});


test('remove breakpoint', function(t) {
  t.plan(4);

  setup({
    breakpoint: 2,
    type: 'script'
  });

  var breakpoint = new Breakpoint({
    number: 1,
    type: 'scriptId',
    line: 100,
    column: 100,
    groupId: 100,
    hitCount: 100,
    enabled: true,
    ignoreCount: 19,
    _client: client
  });

  manager._breakpoints.push(breakpoint);

  t.equal(manager.getBreakpoints().length, 1, 'should have one breakpoint in manager');

  manager.on('change', function() {
    t.equal(manager.getBreakpoints().length, 0, 'should have no breakpoint');
  });

  manager
    .remove(breakpoint)
    .then(function(breakpoint) {
      t.notOk(breakpoint._client, 'should remove the client when success');
    })
    .done();

  t.ok(client.request.calledWith('clearbreakpoint'), 'should call request with command clearbreakpoint');

});
